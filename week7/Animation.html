<!DOCTYPE html>
<html>

<head>

<title>BioLogic Project</title>
<meta charset="utf-8">

<script type="text/javascript" src="/lib/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="/lib/webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    uniform vec4 uColor;

    uniform vec3 uReverseLightDirection;

    uniform bool uUseLighting;

    varying vec3 transformedNormal;

    void main(void) {
        //gl_FragColor = vec4(1.0, 1.0, 0.0, 1.0);

        if (!uUseLighting) {
            gl_FragColor = vec4(0.2, 0.2, 0.2, 0.1);
        }
        else {
            vec3 normal = normalize(transformedNormal);
            float light = dot(normal, uReverseLightDirection);

            gl_FragColor = uColor;
            gl_FragColor.rgb *= 0.1 + light;
        }
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform bool uUseLighting;

    varying vec3 transformedNormal;
    varying vec3 vPosition;

    void main(void) {
        vPosition = aVertexPosition;
        // vPosition.x -= vPosition.z*vPosition.z*0.025;

        gl_Position = uPMatrix * uMVMatrix * vec4(vPosition, 1.0);

        if (uUseLighting) 
            transformedNormal = uNMatrix * aVertexNormal;
    }
</script>


<script type="text/javascript">

function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

var mouseDown = false;
var lastMouseX = null;
var lastMouseY = null;

var rAngle = 0;
var mvRotationMatrix = mat4.create();
mat4.identity(mvRotationMatrix);

function handleMouseDown(event) {
    mouseDown = true;
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
}

function handleMouseUp(event) {
    mouseDown = false;
}

function handleMouseMove(event) {
    if (!mouseDown) {
        return;
    }

    var newX = event.clientX;
    var newY = event.clientY;

    var deltaX = newX - lastMouseX;

    var newRotationMatrix = mat4.create();
    mat4.identity(newRotationMatrix);
    //mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

    var deltaY = newY - lastMouseY;

    if (rAngle <= 150 && rAngle >= -150) {
        if (rAngle + deltaY > 150) {
            deltaY = 150 - rAngle;
            rAngle = 150;
        }
        else if (rAngle + deltaY < -150) {
            deltaY = -150 - rAngle;
            rAngle = -150;
        }
        else {
            rAngle += deltaY;
        }

        mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
        mat4.multiply(newRotationMatrix, mvRotationMatrix, mvRotationMatrix);
    }

    lastMouseX = newX
    lastMouseY = newY;
}

var ballRelativeX = 0.0;
var ballRelativeY = 0.0;
var ballRelativeZ = 0.0;

var ballTravel = 0;

var ballLocationIndexX = 0;
var ballLocationIndexZ = 0;

var dialX = 0.0;

var orgbmi;
var bmi;
var age;

var lastTime = 0;
var idleTick = 0;
var sec = 0;
var aged = 0;

var trenchWidth = 2; // in terms of number of planeGridX
var trenchGrid = trenchWidth * 10;
var trenchDepthScale = 0.01;
var trenchLocations = [];
var trenchDepths = [];

var xoffsets = []

var planeLengthX = 2.4;
var planeLengthZ = 10.0;

var planeGridX = 28;
var planeGridZ = 31;

var planeVertices = [];
var planeNormals = [];
var planeIndices = [];

var xfac = 8;
var zfac = 30;
var curfac = 10;

// function handleKeyDown(event) {
//     //alert(event.keyCode);

//     var diffX = planeLengthX / planeGridX;
//     var diffZ = planeLengthZ / planeGridZ;

//     if (event.keyCode == 82) {
//         // mat4.identity(mvRotationMatrix);
//         // rAngle = 0;
//         //console.log(idleTick);
//         ballRelativeZ = 0 - planeLengthZ / planeGridZ;
//     }
//     else if (event.keyCode == 81) {
//         // mat4.identity(mvRotationMatrix);
//         // rAngle = 0;
//         //console.log(idleTick);
//         // ballRelativeZ = 0 - planeLengthZ / planeGridZ;
//         // planeGridZ--;
//         // if (planeGridZ < 0) planeGridZ = 0;
//     }
//     else if (event.keyCode == 68) {
//         //console.log(Math.floor(ballRelativeX/diffX+0.01));
//         //console.log(Math.ceil(ballRelativeZ/diffZ-0.01));
//         ballLocationIndexX = Math.floor(ballRelativeX/diffX+0.01);
//         if (ballLocationIndexX > 0) {

//             trenchLocations[ballLocationIndexX-1] = 1;
//             trenchLocations[ballLocationIndexX] = 1;

//             trenchDepths[ballLocationIndexX] += 1;
//             // var offset = trenchDepthScale*Math.cos(Math.PI);
//             // ballRelativeY += offset;
//         }
//     }
//     else if (event.keyCode == 37) {
//         idleTick = 0;
//         lastTime = 0;
//         sec = 0;

//         ballLocationIndexX = Math.floor(ballRelativeX/diffX+0.01);
//         // ballLocationIndexZ = Math.abs(Math.ceil(ballRelativeZ/diffZ-0.01));

//         if (ballLocationIndexX > 1) {
//             ballRelativeX -= diffX;

//             // ballRelativeY = ballRelativeX * ballRelativeX / xfac + ballRelativeZ * ballRelativeZ / zfac + ballRelativeX*0.003;

//             // ballLocationIndexX--;
//             // var offset = trenchDepths[ballLocationIndexX]*trenchDepthScale*Math.cos(Math.PI);
//             // ballRelativeY += offset;

//             bmi = parseFloat(bmi)+1.0;
//             orgbmi = bmi;
//             document.getElementById("bmi").setAttribute("value", bmi.toFixed(1));

//             dialX-=1.0;
//             if (dialX < 0) dialX = 0.0;
//         }
//     }
//     else if (event.keyCode == 39) {
//         idleTick = 0;
//         lastTime = 0;
//         sec = 0;

//         ballLocationIndexX = Math.floor(ballRelativeX/diffX+0.01);
//         // ballLocationIndexZ = Math.abs(Math.ceil(ballRelativeZ/diffZ-0.01));

//         if (ballLocationIndexX < planeGridX - 1) {
//             ballRelativeX += diffX;

//             // ballRelativeY = ballRelativeX * ballRelativeX / xfac + ballRelativeZ * ballRelativeZ / zfac + ballRelativeX*0.003;

//             // ballLocationIndexX++;
//             // var offset = trenchDepths[ballLocationIndexX]*trenchDepthScale*Math.cos(Math.PI);
//             // ballRelativeY += offset;

//             bmi = parseFloat(bmi)-1.0;
//             orgbmi = bmi;
//             document.getElementById("bmi").setAttribute("value", bmi.toFixed(1));

//             dialX+=1.0;
//             if (dialX > planeGridX) dialX = planeGridX;
//         }
//     }
//     else if (event.keyCode == 38) {
//         ballLocationIndexX = Math.floor(ballRelativeX/diffX+0.01);
//         ballLocationIndexZ = Math.abs(Math.ceil(ballRelativeZ/diffZ-0.01));
        
//         if (ballLocationIndexZ < planeGridZ) {
//             ballRelativeZ -= diffZ;

//             // ballRelativeY = ballRelativeX * ballRelativeX / xfac + ballRelativeZ * ballRelativeZ / zfac + ballRelativeX*0.003;

//             // ballLocationIndexX = Math.floor(ballRelativeX/diffX+0.01);
//             // var offset = trenchDepths[ballLocationIndexX]*trenchDepthScale*Math.cos(Math.PI);
//             // ballRelativeY += offset;

//             // ballRelativeY = planeVertices[(ballLocationIndexZ+1)*planeGridX*trenchGrid/trenchWidth*4*3+ballLocationIndexX*trenchGrid/trenchWidth*4*3+1];

//         }
//     }
//     else if (event.keyCode == 40) {
//         ballLocationIndexX = Math.floor(ballRelativeX/diffX+0.01);
//         ballLocationIndexZ = Math.abs(Math.ceil(ballRelativeZ/diffZ-0.01));

//         if (ballLocationIndexZ > 1) {
//             ballRelativeZ += diffZ;

//             // ballRelativeY = ballRelativeX * ballRelativeX / xfac + ballRelativeZ * ballRelativeZ / zfac + ballRelativeX*0.003;

//             // ballLocationIndexX = Math.floor(ballRelativeX/diffX+0.01);
//             // var offset = trenchDepths[ballLocationIndexX]*trenchDepthScale*Math.cos(Math.PI);
//             // ballRelativeY += offset;

//             // ballRelativeY = planeVertices[(ballLocationIndexZ-1)*planeGridX*trenchGrid/trenchWidth*4*3+ballLocationIndexX*trenchGrid/trenchWidth*4*3+1];

//         }
//     }
// }

var gl;

function initGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    } catch (e) {
    }
    if (!gl) {
        alert("Could not initialise WebGL, sorry :-(");
    }
}

function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }
    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }
    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }
    gl.shaderSource(shader, str);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

var shaderProgram;

function initShaders() {
    var fragmentShader = getShader(gl, "shader-fs");
    var vertexShader = getShader(gl, "shader-vs");

    shaderProgram = gl.createProgram();

    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialise shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");

    shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, "uColor");

    shaderProgram.reverseLightDirectionLocation = gl.getUniformLocation(shaderProgram, "uReverseLightDirection");
    shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
}


var mvMatrix = mat4.create();
var pMatrix = mat4.create();
var mvMatrixStack = [];

function mvPushMatrix() {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
}

function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
        throw "Invalid PopMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
}

var object = 0;
var colorThemes = [
    [0.92, 0.55, 0.0,  1.0], 
    [0.86, 0.41, 0.0,  1.0],
    [0.88, 0.19, 0.12, 1.0],
    [0.86, 0.33, 0.42, 1.0],
    [0.64, 0.13, 0.13, 1.0],
    [0.38, 0.14, 0.13, 1.0],
    [0.59, 0.55, 0.43, 1.0],
    [0.43, 0.43, 0.44, 1.0],
    [1.0,  0.0,  0.0,  1.0],
    [0.95, 0.55, 0.0,  1.0],
    [0.0,  1.0,  0.0,  1.0],
    [1.0,  1.0,  0.0,  1.0]
]; 

var lightDir = [-0.1, 2.5, 3.0];
var lighting;

function setMatrixUniforms() {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

    var normalMatrix = mat3.create();
    normalMatrix = mat4.toInverseMat3(mvMatrix, normalMatrix);
    normalMatrix = mat3.transpose(normalMatrix);
    gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);

    gl.uniform4fv(shaderProgram.colorUniform, colorThemes[object]);

    vec3.normalize(lightDir);
    gl.uniform3fv(shaderProgram.reverseLightDirectionLocation, lightDir);
    gl.uniform1i(shaderProgram.useLightingUniform, lighting);
}

var planeVertexPositionBuffer;
var planeVertexNormalBuffer;
var planeIndexBuffer;

function initPlaneBuffers() {

    var diffX = planeLengthX / planeGridX;
    var diffZ = planeLengthZ / planeGridZ;

    var diff = trenchWidth * diffX / trenchGrid;

    var i = 0;

    for(var z = 0.0; z > -1*planeLengthZ; z -= diffZ) {

        for(var x = 0.0; x < planeLengthX; x += diff) {

            var nx = x + diff;
            var nz = z - diffZ;

            var y0 = x * x / xfac + z * z / zfac;
            var y1 = x * x / xfac + nz * nz / zfac;
            var y2 = nx * nx / xfac + z * z / zfac;
            var y3 = nx * nx / xfac + nz * nz / zfac;

            planeVertices.push(x); planeVertices.push(y0); planeVertices.push(z);
            planeVertices.push(x); planeVertices.push(y1); planeVertices.push(nz);
            planeVertices.push(nx); planeVertices.push(y2); planeVertices.push(z);
            planeVertices.push(nx); planeVertices.push(y3); planeVertices.push(nz);

            var p0 = [x, y0, z];
            var p1 = [x, y1, nz];
            var p2 = [nx, y2, z];
            var p3 = [nx, y3, nz];

            var a = vec3.create();
            a = vec3.subtract(p1, p0, a);
            var b = vec3.create();
            b = vec3.subtract(p2, p0, b);

            var n = vec3.create();
            n = vec3.cross(b, a, n);

            for (var c = 0; c < 4; c++) { 
                planeNormals.push(n[0]);
                planeNormals.push(n[1]);
                planeNormals.push(n[2]);
            }

            planeIndices.push(i*4); 
            planeIndices.push(i*4+1); 
            planeIndices.push(i*4+3); 

            planeIndices.push(i*4); 
            planeIndices.push(i*4+2); 
            planeIndices.push(i*4+3); 

            i++;      
        }

    }

    planeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(planeVertices), gl.STATIC_DRAW);
    planeVertexPositionBuffer.itemSize = 3;
    planeVertexPositionBuffer.numItems = planeVertices.length / 3;

    planeVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(planeNormals), gl.STATIC_DRAW);
    planeVertexNormalBuffer.itemSize = 3;
    planeVertexNormalBuffer.numItems = planeNormals.length / 3;

    planeIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(planeIndices), gl.STATIC_DRAW);
    planeIndexBuffer.itemSize = 1;
    planeIndexBuffer.numItems = planeIndices.length; 
}

// var tDepths = [];

function updatePlaneBuffers() {

    var diffX = planeLengthX / planeGridX;
    var diffZ = planeLengthZ / planeGridZ;

    var diff = trenchWidth * diffX / trenchGrid;

    var d = 0;
    var u = 0;
    var i = 0;

    var tDepths = [];
    for (var i = 0; i < planeGridX-1; i++) {
        tDepths.push(trenchDepths[i+1]);
        for (var j = 1; j < trenchGrid/trenchWidth; j++) {
            tDepths.push(0);
        }
    }
    for (var j = 0; j < trenchGrid/trenchWidth; j++) {
        tDepths.push(0);
    }

    var shift = Math.floor((5*aged*diffZ)*(5*aged*diffZ)/curfac);
    ballTravel = 0-shift;
    for (var j = 0; j < tDepths.length; j++) {
        if (j+shift > tDepths.length-1) {
            break;
        }
        tDepths[j] = tDepths[j+shift];
    }
    for (; j < tDepths.length; j++) {
        tDepths[j] = 0;
    }

    // var offset = 0.0;
    for(var z = 0.0; z > -1*planeLengthZ; z -= diffZ) {

        d = 0;
        for(var x = 0.0; x < planeLengthX; x += diff) {

            var nx = x + diff;
            var nz = z - diffZ;

            var y0 = x * x / xfac + z * z / zfac;
            var y1 = x * x / xfac + nz * nz / zfac;
            var y2 = nx * nx / xfac + z * z / zfac;
            var y3 = nx * nx / xfac + nz * nz / zfac;

            var basei = u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3;
            planeVertices[basei+0] = x; planeVertices[basei+1] = y0; planeVertices[basei+2] = z;
            planeVertices[basei+3] = x; planeVertices[basei+4] = y1; planeVertices[basei+5] = nz;
            planeVertices[basei+6] = nx; planeVertices[basei+7] = y2; planeVertices[basei+8] = z;
            planeVertices[basei+9] = nx; planeVertices[basei+10] = y3; planeVertices[basei+11] = nz;

            var p0 = [x, y0, z];
            var p1 = [x, y1, nz];
            var p2 = [nx, y2, z];
            var p3 = [nx, y3, nz];

            var a = vec3.create();
            a = vec3.subtract(p1, p0, a);
            var b = vec3.create();
            b = vec3.subtract(p2, p0, b);

            var n = vec3.create();
            n = vec3.cross(b, a, n);

            for (var c = 0; c < 4; c++) { 
                planeNormals[basei+c*3+0] = n[0];
                planeNormals[basei+c*3+1] = n[1];
                planeNormals[basei+c*3+2] = n[2];
            }

            d++; 
        }

        d = 0;
        shift = Math.floor((z-aged*diffZ)*(z-aged*diffZ)/curfac+x*x/10);
        for(var x = 0.0; x < planeLengthX; x += diff) {
            // offset = ((z-aged*diffZ)*(z-aged*diffZ)/curfac+x*x/10-Math.floor((z-aged*diffZ)*(z-aged*diffZ)/curfac+x*x/10))/10;
            // console.log(offset);

            if (tDepths[d+shift] > 0) {
                for (var j = 0; j < trenchGrid; j++) {
                    var angle1 = Math.PI/2+j*Math.PI/trenchGrid; //+offset*Math.PI
                    // if (angle1 > 3*Math.PI/2) angle1 = 3*Math.PI/2;
                    var cosx1 = tDepths[d+shift]*trenchDepthScale*Math.cos(angle1);
                    var sx1 = x+j*diff;

                    var angle2 = Math.PI/2+(j+1)*Math.PI/trenchGrid; //+offset*Math.PI
                    // if (angle2 > 3*Math.PI/2) angle2 = 3*Math.PI/2;
                    var cosx2 = tDepths[d+shift]*trenchDepthScale*Math.cos(angle2);
                    var sx2 = x+(j+1)*diff;

                    var basei = u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+j*4*3;

                    var tmpy1 = sx1 * sx1 / xfac + (z-diffZ) * (z-diffZ) / zfac + cosx1;
                    var tmpy3 = sx2 * sx2 / xfac + (z-diffZ) * (z-diffZ) / zfac + cosx2;

                    var sy1 = planeVertices[basei+4]; 
                    var sy3 = planeVertices[basei+10];

                    if (tmpy1 < sy1) {
                        sy1 = tmpy1;
                        planeVertices[basei+4] = sy1;
                    }
                    if (tmpy3 < sy3) {
                        sy3 = tmpy3;
                        planeVertices[basei+10] = sy3;
                    }
                }
            }

            if (tDepths[d] > 0) { 

                for (var j = 0; j < trenchGrid; j++) {
                    var angle1 = Math.PI/2+j*Math.PI/trenchGrid; //+offset*Math.PI
                    // if (angle1 > 3*Math.PI/2) angle1 = 3*Math.PI/2;
                    var cosx1 = tDepths[d]*trenchDepthScale*Math.cos(angle1);
                    var sx1 = x+j*diff;

                    var angle2 = Math.PI/2+(j+1)*Math.PI/trenchGrid; //+offset*Math.PI
                    // if (angle2 > 3*Math.PI/2) angle2 = 3*Math.PI/2;
                    var cosx2 = tDepths[d]*trenchDepthScale*Math.cos(angle2);
                    var sx2 = x+(j+1)*diff;

                    var basei = u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+j*4*3;

                    var tmpy0 = sx1 * sx1 / xfac + z * z / zfac + cosx1;
                    // var tmpy1 = sx1 * sx1 / xfac + (z-diffZ) * (z-diffZ) / zfac + cosx1;
                    var tmpy2 = sx2 * sx2 / xfac + z * z / zfac + cosx2;
                    // var tmpy3 = sx2 * sx2 / xfac + (z-diffZ) * (z-diffZ) / zfac + cosx2;

                    var sy0 = planeVertices[basei+1]; 
                    // var sy1 = planeVertices[basei+4]; 
                    var sy2 = planeVertices[basei+7]; 
                    // var sy3 = planeVertices[basei+10];

                    if (tmpy0 < sy0) {
                        sy0 = tmpy0;
                        planeVertices[basei+1] = sy0;
                    }
                    // if (tmpy1 < sy1) {
                    //     sy1 = tmpy1;
                    //     planeVertices[basei+4] = sy1;
                    // }
                    if (tmpy2 < sy2) {
                        sy2 = tmpy2;
                        planeVertices[basei+7] = sy2;
                    }
                    // if (tmpy3 < sy3) {
                    //     sy3 = tmpy3;
                    //     planeVertices[basei+10] = sy3;
                    // }

                }
            }

            d++;
        }

        u++;

        // offset = (z-aged*diffZ)*(z-aged*diffZ)/curfac+x*x/10-Math.floor((z-aged*diffZ)*(z-aged*diffZ)/curfac+x*x/10);
        // console.log("%d, %f", u, offset);
        shift = Math.floor((z-aged*diffZ)*(z-aged*diffZ)/curfac+x*x/10);
        for (var j = 0; j < tDepths.length; j++) {
            if (j+shift > tDepths.length-1) {
                break;
            }
            tDepths[j] = tDepths[j+shift];
        }
        for (; j < tDepths.length; j++) {
            tDepths[j] = 0;
        }
        // tDepths[tDepths.length-1] = 0;
    }

    u = 0;
    d = 0;
    for(var z = 0.0; z > -1*planeLengthZ; z -= diffZ) {
        d = 0;

        for(var x = 0.0; x < planeLengthX; x += diff)  {

            var cy0 = planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+1];
            var cy1 = planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+4];
            var cy2 = planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+7];
            var cy3 = planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+10];

            var ly1 = planeVertices[(u-1)*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+4];
            var ly3 = planeVertices[(u-1)*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+10];

            var ny0 = planeVertices[(u+1)*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+1];
            var ny2 = planeVertices[(u+1)*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+7];

            if (cy0 < ly1) {
                planeVertices[(u-1)*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+4] = cy0;
            }
            else if (ly1 < cy0) {
                planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+1] = ly1;
            }

            if (cy2 < ly3) {
                planeVertices[(u-1)*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+10] = cy2;
            }
            else if (ly3 < cy2) {
                planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+7] = ly3;
            }
            d++;
        }

        u++;
    }

    u = 0;
    d = 0;
    for(var z = 0.0; z > -1*planeLengthZ; z -= diffZ) {
        d = 0;

        for(var x = 0.0; x < planeLengthX; x += diff)  {

            if (x < planeLengthX-diff) {
                var cy2 = planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+7];
                var ny0 = planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+(d+1)*4*3+1];

                var cy3 = planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+10];
                var ny1 = planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+(d+1)*4*3+4];

                
                if (ny0 < cy2) {
                    planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+7] = ny0;
                }
                if (cy2 < ny0) {
                    planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+(d+1)*4*3+1] = cy2;
                }

                if (ny1 < cy3) {
                    planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+d*4*3+10] = ny1;
                }
                if (cy3 < ny1) {
                    planeVertices[u*planeGridX*trenchGrid/trenchWidth*4*3+(d+1)*4*3+4] = cy3;
                }
            }

            d++;
        }

        u++;
    }

    u = 0;
    i = 0;
    for(var z = 0.0; z > -1*planeLengthZ; z -= diffZ) {
        d = 0;

        for(var x = 0.0; x < planeLengthX; x += diff) {

            var nx = x + diff;
            var nz = z - diffZ;

            var basei = u*planeGridX/trenchWidth*trenchGrid*4*3+d*4*3;

            var y0 = planeVertices[basei+1];
            var y1 = planeVertices[basei+4];
            var y2 = planeVertices[basei+7];
            var y3 = planeVertices[basei+10];

            var p0 = [x, y0, z];
            var p1 = [x, y1, nz];
            var p2 = [nx, y2, z];
            var p3 = [nx, y3, nz];

            var a = vec3.create();
            a = vec3.subtract(p1, p0, a);
            var b = vec3.create();
            b = vec3.subtract(p2, p0, b);

            var n = vec3.create();
            n = vec3.cross(b, a, n);

            for (var c = 0; c < 4; c++) { 
                planeNormals[i++] = n[0];
                planeNormals[i++] = n[1];
                planeNormals[i++] = n[2];
            }
            d++;
        }
        u++;
    } 

    planeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(planeVertices), gl.STATIC_DRAW);
    planeVertexPositionBuffer.itemSize = 3;
    planeVertexPositionBuffer.numItems = planeVertices.length / 3;

    planeVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(planeNormals), gl.STATIC_DRAW);
    planeVertexNormalBuffer.itemSize = 3;
    planeVertexNormalBuffer.numItems = planeNormals.length / 3;

    planeIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(planeIndices), gl.STATIC_DRAW);
    planeIndexBuffer.itemSize = 1;
    planeIndexBuffer.numItems = planeIndices.length; 
}

var dividerVertexPositionBuffer;

var slidu = 1;
var slidz = planeLengthZ / planeGridZ;
var slids = 0;

function initDividerBuffers() {

    var diffX = planeLengthX / planeGridX;
    var diffZ = planeLengthZ / planeGridZ;

    var diff = trenchWidth * diffX / trenchGrid;

    var vertices = [];

    var u = 0;
    var d = 0;
    for (var z = 0.0; z > -1*planeLengthZ; z -= diffZ) {
        d = 0;

        for(var x = 0.0; x < planeLengthX; x += diffX) {
            
            if (d == 11 || d == 16 || d == 21) {
                var nz = z - diffZ;

                var y0 = planeVertices[u*planeGridX/trenchWidth*trenchGrid*4*3+d*trenchGrid/trenchWidth*4*3+1]; 
                var y1 = planeVertices[u*planeGridX/trenchWidth*trenchGrid*4*3+d*trenchGrid/trenchWidth*4*3+4];

                vertices.push(x);
                vertices.push(y0);
                vertices.push(z);

                vertices.push(x);
                vertices.push(y1);
                vertices.push(nz);
            }

            d++;
        }
        u++;
    }

    u = slidu;
    for (var z = -1*slidz; z >= -1*planeLengthZ; z -= 2*diffZ) {

        d = 0;
        for(var x = 0.0; x < planeLengthX; x += diff) {
            var nx = x + diff;

            var y0 = planeVertices[u*planeGridX/trenchWidth*trenchGrid*4*3+d*4*3+1];
            var y2 = planeVertices[u*planeGridX/trenchWidth*trenchGrid*4*3+d*4*3+7]; 

            vertices.push(x);
            vertices.push(y0);
            vertices.push(z);

            vertices.push(nx);
            vertices.push(y2);
            vertices.push(z);

            d++;
        }
        u+=2;
    }

    dividerVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, dividerVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    dividerVertexPositionBuffer.itemSize = 3;
    dividerVertexPositionBuffer.numItems = vertices.length / 3;
}

var latitudeBands = 50;
var longitudeBands = 50;
var radius = 0.035; 

var ballVertexPositionBuffer;
var ballVertexNormalBuffer;
var ballIndexBuffer;

function initBallBuffers() {
    var vertices = [];
    var normals = [];
    for (var latNum = 0; latNum <= latitudeBands; latNum++) {
        var theta = latNum * Math.PI / latitudeBands;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);

        for (var longNum = 0; longNum <= longitudeBands; longNum++) {
            var phi = longNum * 2 * Math.PI / longitudeBands;
            var sinPhi = Math.sin(phi);
            var cosPhi = Math.cos(phi);

            var x = cosPhi * sinTheta;
            var y = cosTheta;
            var z = sinPhi * sinTheta;

            normals.push(x);
            normals.push(y);
            normals.push(z);

            vertices.push(radius*x);
            vertices.push(radius*y);
            vertices.push(radius*z);
        }
    }

    var indices = [];
    for (var latNum = 0; latNum < latitudeBands; latNum++) {
        for (var longNum = 0; longNum < longitudeBands; longNum++) {
            var first = (latNum * (longitudeBands + 1)) + longNum;
            var second = first + longitudeBands + 1;

            indices.push(first);
            indices.push(second);
            indices.push(first + 1);

            indices.push(second);
            indices.push(second + 1);
            indices.push(first + 1);
        }
    }

    ballVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    ballVertexPositionBuffer.itemSize = 3;
    ballVertexPositionBuffer.numItems = vertices.length / 3;

    ballVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    ballVertexNormalBuffer.itemSize = 3;
    ballVertexNormalBuffer.numItems = normals.length / 3;

    ballIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ballIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    ballIndexBuffer.itemSize = 1;
    ballIndexBuffer.numItems = indices.length;
}

var scaleBarWidth = 4.7;
var scaleBarHeight = 0.1;
var scaleBarZ = -0.5;

var rscaleBarVertexPositionBuffer;
var rscaleBarVertexNormalBuffer;
var rscaleBarIndexBuffer;

var oscaleBarVertexPositionBuffer;
var oscaleBarVertexNormalBuffer;
var oscaleBarIndexBuffer;

var yscaleBarVertexPositionBuffer;
var yscaleBarVertexNormalBuffer;
var yscaleBarIndexBuffer;

var gscaleBarVertexPositionBuffer;
var gscaleBarVertexNormalBuffer;
var gscaleBarIndexBuffer;

function initRedScaleBarBuffers() {
    var vertices = [];
    var normals = [];
    var indices = [];
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / (planeGridX-1);
    var index = 0;
    var nGrid = 0;
    for (var x = -halfW+nGrid*diffW; x < halfW-2*diffW; x += diffW) {
        if (nGrid == 10) break;

        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        indices.push(index*4);
        indices.push(index*4+1);
        indices.push(index*4+3);

        indices.push(index*4);
        indices.push(index*4+2);
        indices.push(index*4+3);

        index++;
        nGrid++;

        for (var i = 0; i < 4; i++) 
            normals = normals.concat([0.0, 0.0, 1.0]);
    }

    rscaleBarVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, rscaleBarVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    rscaleBarVertexPositionBuffer.itemSize = 3;
    rscaleBarVertexPositionBuffer.numItems = vertices.length / 3;

    rscaleBarVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, rscaleBarVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    rscaleBarVertexNormalBuffer.itemSize = 3;
    rscaleBarVertexNormalBuffer.numItems = normals.length / 3;

    rscaleBarIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rscaleBarIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    rscaleBarIndexBuffer.itemSize = 1;
    rscaleBarIndexBuffer.numItems = indices.length;
}
function initOrangeScaleBarBuffers() {
    var vertices = [];
    var normals = [];
    var indices = [];
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / (planeGridX-1);
    var index = 0;
    var nGrid = 10;
    for (var x = -halfW+nGrid*diffW; x < halfW-2*diffW; x += diffW) {
        if (nGrid == 15) break;

        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        indices.push(index*4);
        indices.push(index*4+1);
        indices.push(index*4+3);

        indices.push(index*4);
        indices.push(index*4+2);
        indices.push(index*4+3);

        index++;
        nGrid++;

        for (var i = 0; i < 4; i++) 
            normals = normals.concat([0.0, 0.0, 1.0]);
    }

    oscaleBarVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, oscaleBarVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    oscaleBarVertexPositionBuffer.itemSize = 3;
    oscaleBarVertexPositionBuffer.numItems = vertices.length / 3;

    oscaleBarVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, oscaleBarVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    oscaleBarVertexNormalBuffer.itemSize = 3;
    oscaleBarVertexNormalBuffer.numItems = normals.length / 3;

    oscaleBarIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, oscaleBarIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    oscaleBarIndexBuffer.itemSize = 1;
    oscaleBarIndexBuffer.numItems = indices.length;
}
function initYellowScaleBarBuffers() {
    var vertices = [];
    var normals = [];
    var indices = [];
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / (planeGridX-1);
    var index = 0;
    var nGrid = 15;
    for (var x = -halfW+nGrid*diffW; x < halfW-2*diffW; x += diffW) {
        if (nGrid == 20) break;

        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        indices.push(index*4);
        indices.push(index*4+1);
        indices.push(index*4+3);

        indices.push(index*4);
        indices.push(index*4+2);
        indices.push(index*4+3);

        index++;
        nGrid++;

        for (var i = 0; i < 4; i++) 
            normals = normals.concat([0.0, 0.0, 1.0]);
    }

    yscaleBarVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, yscaleBarVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    yscaleBarVertexPositionBuffer.itemSize = 3;
    yscaleBarVertexPositionBuffer.numItems = vertices.length / 3;

    yscaleBarVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, yscaleBarVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    yscaleBarVertexNormalBuffer.itemSize = 3;
    yscaleBarVertexNormalBuffer.numItems = normals.length / 3;

    yscaleBarIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, yscaleBarIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    yscaleBarIndexBuffer.itemSize = 1;
    yscaleBarIndexBuffer.numItems = indices.length;
}
function initGreenScaleBarBuffers() {
    var vertices = [];
    var normals = [];
    var indices = [];
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / (planeGridX-1);
    var index = 0;
    var nGrid = 20;
    for (var x = -halfW+nGrid*diffW; x < halfW-2*diffW; x += diffW) {
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        indices.push(index*4);
        indices.push(index*4+1);
        indices.push(index*4+3);

        indices.push(index*4);
        indices.push(index*4+2);
        indices.push(index*4+3);

        index++;
        nGrid++;

        for (var i = 0; i < 4; i++) 
            normals = normals.concat([0.0, 0.0, 1.0]);
    }

    gscaleBarVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gscaleBarVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gscaleBarVertexPositionBuffer.itemSize = 3;
    gscaleBarVertexPositionBuffer.numItems = vertices.length / 3;

    gscaleBarVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gscaleBarVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    gscaleBarVertexNormalBuffer.itemSize = 3;
    gscaleBarVertexNormalBuffer.numItems = normals.length / 3;

    gscaleBarIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gscaleBarIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    gscaleBarIndexBuffer.itemSize = 1;
    gscaleBarIndexBuffer.numItems = indices.length;
}

var rmarkerVertexPositionBuffer;
var omarkerVertexPositionBuffer;
var ymarkerVertexPositionBuffer;
var gmarkerVertexPositionBuffer;

function initRedMarkerBuffers() {
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / (planeGridX-1);

    var vertices = [];
    var nGrid = 0;
    for (var x = -halfW+nGrid*diffW; x <= halfW-2*diffW; x += diffW) {
        if (nGrid == 10) break;
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);
        nGrid++;
    }

    rmarkerVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, rmarkerVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    rmarkerVertexPositionBuffer.itemSize = 3;
    rmarkerVertexPositionBuffer.numItems = vertices.length / 3;
}
function initOrangeMarkerBuffers() {
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / (planeGridX-1);

    var vertices = [];
    var nGrid = 10;
    for (var x = -halfW+nGrid*diffW; x <= halfW-2*diffW; x += diffW) {
        if (nGrid == 15) break;
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);
        nGrid++;
    }

    omarkerVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, omarkerVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    omarkerVertexPositionBuffer.itemSize = 3;
    omarkerVertexPositionBuffer.numItems = vertices.length / 3;
}
function initYellowMarkerBuffers() {
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / (planeGridX-1);

    var vertices = [];
    var nGrid = 15;
    for (var x = -halfW+nGrid*diffW; x <= halfW-2*diffW; x += diffW) {
        if (nGrid == 20) break;
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);
        nGrid++;
    }

    ymarkerVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ymarkerVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    ymarkerVertexPositionBuffer.itemSize = 3;
    ymarkerVertexPositionBuffer.numItems = vertices.length / 3;
}
function initGreenMarkerBuffers() {
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / (planeGridX-1);

    var vertices = [];
    var nGrid = 20;
    for (var x = -halfW+nGrid*diffW; x <= halfW-diffW; x += diffW) {
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);
        nGrid++;
    }

    gmarkerVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gmarkerVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gmarkerVertexPositionBuffer.itemSize = 3;
    gmarkerVertexPositionBuffer.numItems = vertices.length / 3;
}

var dialVertexPositionBuffer;
var dialVertexNormalBuffer;
var dialIndexBuffer;

function initDialBuffers() {
    var diffW = scaleBarWidth / (planeGridX-1);
    var halfW = diffW / 3;
    var halfH = scaleBarHeight / 3;

    var vertices = [];
    vertices.push(-halfW);
    vertices.push(halfH);
    vertices.push(scaleBarZ);

    vertices.push(0.0);
    vertices.push(-halfH);
    vertices.push(scaleBarZ);

    vertices.push(halfW);
    vertices.push(halfH);
    vertices.push(scaleBarZ);

    var normals = [];
    for (var i = 0; i < 3; i++) 
        normals = normals.concat([0.0, 0.0, 1.0]);

    var indices = [ 0, 1, 2 ];

    dialVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, dialVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    dialVertexPositionBuffer.itemSize = 3;
    dialVertexPositionBuffer.numItems = vertices.length / 3;

    dialVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, dialVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    dialVertexNormalBuffer.itemSize = 3;
    dialVertexNormalBuffer.numItems = normals.length / 3;

    dialIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dialIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    dialIndexBuffer.itemSize = 1;
    dialIndexBuffer.numItems = indices.length;
}

function initBuffers() {
    initPlaneBuffers();

    initDividerBuffers();

    initBallBuffers();

    initRedScaleBarBuffers();
    initOrangeScaleBarBuffers();
    initYellowScaleBarBuffers();
    initGreenScaleBarBuffers();

    initRedMarkerBuffers();
    initOrangeMarkerBuffers();
    initYellowMarkerBuffers();
    initGreenMarkerBuffers();

    initDialBuffers();
}


function drawPlane() {
    updatePlaneBuffers();

    mvPushMatrix();

    mat4.translate(mvMatrix, [-1.2, -0.45, -1.55]);
    mat4.multiply(mvMatrix, mvRotationMatrix);

    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, planeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, planeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);

    object = 3;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, planeIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    // mvPopMatrix();
}

function drawDivider() {
    initDividerBuffers();

    // mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.001, 0.001]);

    gl.bindBuffer(gl.ARRAY_BUFFER, dividerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, dividerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms();

    gl.drawArrays(gl.LINES, 0, dividerVertexPositionBuffer.numItems);

    // mvPopMatrix();
}

function drawBall() {
    // mvPushMatrix();

    if (!(dialX > 0.0 && bmi < 45.0)) {
        ballTravel = 0;
        dialX = 0.0;
        bmi = 45.0;
        ballRelativeX = planeLengthX / planeGridX;
    }

    ballLocationIndexX = Math.floor(ballRelativeX/(planeLengthX / planeGridX)+0.01);
    ballLocationIndexZ = Math.abs(Math.ceil(ballRelativeZ/(planeLengthZ / planeGridZ)-0.01));

    ballRelativeY = planeVertices[ballLocationIndexZ*planeGridX*trenchGrid/trenchWidth*4*3+ballLocationIndexX*trenchGrid/trenchWidth*4*3+ballTravel*4*3+1];   

    mat4.translate(mvMatrix, [0.0, radius, 0.0]);
    mat4.translate(mvMatrix, [ballRelativeX-aged*0.001+ballTravel*trenchWidth*planeLengthX/planeGridX/trenchGrid, ballRelativeY, ballRelativeZ]);

    gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, ballVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, ballVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ballIndexBuffer);

    object = 0;
    setMatrixUniforms();
    
    gl.drawElements(gl.TRIANGLES, ballIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    mvPopMatrix();
}

function drawRedScaleBar() {
    mvPushMatrix();

    mat4.translate(mvMatrix, [0.1, -1.1, -2.4]);

    gl.bindBuffer(gl.ARRAY_BUFFER, rscaleBarVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, rscaleBarVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, rscaleBarVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, rscaleBarVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rscaleBarIndexBuffer);

    object = 8;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, rscaleBarIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //mvPopMatrix();
}
function drawOrangeScaleBar() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.001, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, oscaleBarVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, oscaleBarVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, oscaleBarVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, oscaleBarVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, oscaleBarIndexBuffer);

    object = 9;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, oscaleBarIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //mvPopMatrix();
}
function drawYellowScaleBar() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.001, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, yscaleBarVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, yscaleBarVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, yscaleBarVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, yscaleBarVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, yscaleBarIndexBuffer);

    object = 11;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, yscaleBarIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //mvPopMatrix();
}
function drawGreenScaleBar() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.0015, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, gscaleBarVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, gscaleBarVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, gscaleBarVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, gscaleBarVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gscaleBarIndexBuffer);

    object = 10;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, gscaleBarIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //mvPopMatrix();
}

function drawRedMarker() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, -0.001, 0.001]);

    gl.bindBuffer(gl.ARRAY_BUFFER, rmarkerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, rmarkerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms();

    gl.drawArrays(gl.LINES, 0, rmarkerVertexPositionBuffer.numItems);

    //mvPopMatrix();
}
function drawOrangeMarker() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, omarkerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, omarkerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms();

    gl.drawArrays(gl.LINES, 0, omarkerVertexPositionBuffer.numItems);

    //mvPopMatrix();
}
function drawYellowMarker() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, ymarkerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, ymarkerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms();

    gl.drawArrays(gl.LINES, 0, ymarkerVertexPositionBuffer.numItems);

    //mvPopMatrix();
}
function drawGreenMarker() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, gmarkerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, gmarkerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms();

    gl.drawArrays(gl.LINES, 0, gmarkerVertexPositionBuffer.numItems);

    //mvPopMatrix();
}

function drawDial() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [dialX*scaleBarWidth/(planeGridX-1)-scaleBarWidth/2, scaleBarHeight-0.017, 0.001]);

    gl.bindBuffer(gl.ARRAY_BUFFER, dialVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, dialVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, dialVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, dialVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dialIndexBuffer);

    object = 1;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, dialIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    mvPopMatrix();
}

function drawScene() {
    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, pMatrix);
    mat4.identity(mvMatrix);

    lighting = true;
    drawPlane();

    lighting = false;
    drawDivider();
    lighting = true;

    drawBall();

    drawRedScaleBar();
    drawOrangeScaleBar();
    drawYellowScaleBar();
    drawGreenScaleBar();

    lighting = false;
    drawRedMarker();
    drawOrangeMarker();
    drawGreenMarker();
    drawYellowMarker();
    lighting = true;

    drawDial();
}

var oldBallTravel = 0;
var startSimulate = false;

function animate() {
    var timeNow = new Date().getTime();

    if (lastTime != 0) {
        var elapsed = timeNow - lastTime;

        idleTick += elapsed / 1000;

        ballLocationIndexX = Math.floor(ballRelativeX/(planeLengthX / planeGridX)+0.01);
        ballLocationIndexZ = Math.abs(Math.ceil(ballRelativeZ/(planeLengthZ / planeGridZ)-0.01));

        if (idleTick > 1 && startSimulate) {

            sec += 1;
            slids++;
            if (sec == 1 || sec == 2) {
                if (age < 60) {
                    slidu = slidu == 1 ? 0 : 1;
                    slidz = slidz == 0 ? planeLengthZ/planeGridZ : 0;

                    if (sec == 1) {
                        age = parseInt(age)+1;
                        document.getElementById("age").value = age.toFixed(0);
                    }
                }
                else {
                    startSimulate = false;
                }   
            }
            if (sec == 2) {
                if (age < 60) {
                    aged++;    
                    // console.log(slids);

                    age = parseInt(age)+1;
                    document.getElementById("age").value = age.toFixed(0);    

                    if (dialX > 0.0 && bmi < 45.0) {
                        bmi = orgbmi-ballTravel*0.1;
                        // console.log(bmi);
                        document.getElementById("bmi").value = bmi.toFixed(1); 

                        // console.log(ballTravel%5);

                        dialX += (ballTravel-oldBallTravel)/10.0;
                        // console.log(ballTravel);
                        // console.log(oldBallTravel);

                        oldBallTravel = ballTravel;

                        ballTravel = 0;
                    }

                }       
                else {
                    startSimulate = false;
                }

                sec = 0; 
            }

            if (ballLocationIndexX > 0 && ballLocationIndexZ == 1) {
                if (trenchDepths[ballLocationIndexX] < 10) {

                    trenchLocations[ballLocationIndexX-1] = 1;
                    trenchLocations[ballLocationIndexX] = 1;

                    trenchDepths[ballLocationIndexX] += 1;
                }
            }

            idleTick = 0;
        }
    }
    lastTime = timeNow;
}

var request;

function tick() {
    request = requestAnimFrame(tick);

    drawScene();
    animate();
}

function webGLStart() {
    var canvas = document.getElementById("myCanvas");

    initGL(canvas);
    initShaders();
    initBuffers();

    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);

    canvas.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;

    // document.onkeydown = handleKeyDown;

    rAngle = 60;
    mat4.rotate(mvRotationMatrix, degToRad(rAngle / 10), [1, 0, 0]);

    ballRelativeX = planeLengthX / planeGridX;
    ballRelativeZ = 0 - planeLengthZ / planeGridZ;
    ballRelativeY = ballRelativeX * ballRelativeX / 8 + ballRelativeZ * ballRelativeZ / 25;

    // bmi = document.getElementById("bmi").value;
    // age = document.getElementById("age").value;

    // if (parseFloat(bmi) < 19.0) {
    //     bmi = 19.0;
    //     dialX = planeGridX;
    //     ballRelativeX += planeGridX * planeLengthX / planeGridX;
    // }
    // else if (parseFloat(bmi) > 45.0) {
    //     bmi = 45.0;
    //     dialX = 0.0;
    // }
    // else {
    //     ballRelativeX += (45.0 - parseFloat(bmi)) * planeLengthX / planeGridX;
    // }

    // orgbmi = bmi;

    // for (var i = 0; i < planeGridX; i++) {
    //     trenchLocations[i] = 0;
    //     trenchDepths[i] = 0;
    // }

    // for (var i = 0; i < planeGridX-1; i++) {
    //     tDepths.push(trenchDepths[i+1]);
    //     for (var j = 1; j < trenchGrid/trenchWidth; j++) {
    //         tDepths.push(0);
    //     }
    // }
    // for (var j = 0; j < trenchGrid/trenchWidth; j++) {
    //     tDepths.push(0);
    // }

    // var u = 0;
    // for(var z = 0.0; z > -1*planeLengthZ; z -= planeLengthZ / planeGridZ) {
    //     xoffsets.push(Math.floor(u*u/200)*trenchWidth*planeLengthX/planeGridX/trenchGrid);
    //     u++;
    // }
    // for (var j = 0; j < xoffsets.length; j++) console.log(xoffsets[j]);

    tick();
}

function simulate() {

    ballRelativeX = planeLengthX / planeGridX;
    ballRelativeZ = 0 - planeLengthZ / planeGridZ;
    ballRelativeY = ballRelativeX * ballRelativeX / 8 + ballRelativeZ * ballRelativeZ / 25;

    for (var i = 0; i < planeGridX; i++) {
        trenchLocations[i] = 0;
        trenchDepths[i] = 0;
    }

    startSimulate = true;
    idleTick = 0;
    lastTime = 0;
    ballTravel = 0;
    oldBallTravel = 0;
    dialX = 0.0;
    aged = 0;
    sec = 0;
    age = 20;
    slids = 0;
    slidu = 1;
    slidz = planeLengthZ / planeGridZ;
    document.getElementById("age").value = age.toFixed(0);
    bmi = document.getElementById("bmi").value;
    bmi = parseFloat(Math.floor(bmi));
    if (bmi < 19.0) {
        bmi = 19.0;
        dialX += 26.0;
        ballRelativeX += dialX * planeLengthX / planeGridX;
    }
    else if (bmi > 45.0) {
        bmi = 45.0;
    }
    else {
        dialX += 45.0-bmi;
        ballRelativeX += dialX * planeLengthX / planeGridX;
    }

    ballLocationIndexX = Math.floor(ballRelativeX/(planeLengthX / planeGridX)+0.01);
    ballLocationIndexZ = Math.abs(Math.ceil(ballRelativeZ/(planeLengthZ / planeGridZ)-0.01));

    ballRelativeY = planeVertices[ballLocationIndexZ*planeGridX*trenchGrid/trenchWidth*4*3+ballLocationIndexX*trenchGrid/trenchWidth*4*3+ballTravel*4*3+1];  

    // console.log(bmi);
    document.getElementById('bmi').value = bmi.toFixed(1);
    orgbmi = bmi;

    tick();
}

function terminate() {
    cancelRequestAnimFrame(request);
    startSimulate = false;
}

window.cancelRequestAnimFrame = (function() {
    return  window.cancelAnimationFrame ||
            window.webkitCancelRequestAnimationFrame ||
            window.mozCancelRequestAnimationFrame ||
            window.oCancelRequestAnimationFrame ||
            window.msCancelRequestAnimationFrame ||
            clearTimeout
})();

</script>

</head>

<body onload="webGLStart();">
<br><br><br>
<canvas id="myCanvas" style="padding: 0; margin: auto; display: block;" width="1200" height="600"></canvas>
<table style="border: 0; padding: 10px; margin: auto;">
<tr style="text-align: center;"><td><b>AGE: </b><input type="text" id="age" value="20" disabled /><td width = "10%" style="visibility: hidden;"><td><b>BMI: </b><input type="text" id="bmi" value="45.0" /><td width = "10%" style="visibility: hidden;"><td><button onclick="simulate()">Start</button></td><td width = "5%" style="visibility: hidden;"><td><button onclick="terminate()">Stop</button></td></tr>
</table>
</body>

</html>