<!DOCTYPE html>
<html>

<head>

<title>BioLogic Project</title>
<meta charset="utf-8">

<script type="text/javascript" src="/lib/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="/lib/webgl-utils.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    //varying vec4 vColor;
    varying vec3 transformedNormal;

    // varying vec2 vTextureCoord;
    // uniform sampler2D uSampler;

    uniform vec3 uReverseLightDirection;
    uniform vec4 uColor;

    uniform bool uUseLighting;

    // uniform bool uUseTexture;

    void main(void) {
        // if (uUseTexture) {
        //     gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
        // } else
        if (!uUseLighting) {
            gl_FragColor = vec4(1.0, 1.0, 1.0, 0.1);
        }
        else {
            vec3 normal = normalize(transformedNormal);
            float light = dot(normal, uReverseLightDirection);

            gl_FragColor = uColor;
            gl_FragColor.rgb *= 0.2 + light;
        }
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    //attribute vec4 aVertexColor;
    attribute vec3 aVertexNormal;

    // attribute vec2 aTextureCoord;

    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;

    uniform bool uUseLighting;

    // uniform bool uUseTexture;

    //varying vec4 vColor;
    varying vec3 transformedNormal;

    // varying vec2 vTextureCoord;

    void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);

        // if (uUseTexture)
        //     vTextureCoord = aTextureCoord;

        //vColor = aVertexColor;
        if (uUseLighting)
            transformedNormal = uNMatrix * aVertexNormal;
    }
</script>

<script type="text/javascript">

var gl;

var shaderProgram;

var mvMatrix = mat4.create();
var pMatrix = mat4.create();
var mvMatrixStack = [];

var object = 0;
var colorThemes = [
    [0.92, 0.55, 0.0,  1.0], 
    [0.86, 0.41, 0.0,  1.0],
    [0.88, 0.19, 0.12, 1.0],
    [0.86, 0.33, 0.42, 1.0],
    [0.64, 0.13, 0.13, 1.0],
    [0.38, 0.14, 0.13, 1.0],
    [0.59, 0.55, 0.43, 1.0],
    [0.43, 0.43, 0.44, 1.0],
    [1.0,  0.0,  0.0,  1.0],
    [0.95, 0.75, 0.0,  1.0],
    [0.0,  1.0,  0.0,  1.0]
]; 

var lightDir = [-0.1, 2.0, 2.0];
var lighting;

var mouseDown = false;
var lastMouseX = null;
var lastMouseY = null;

var rAngle = 0;
var mvRotationMatrix = mat4.create();
mat4.identity(mvRotationMatrix);

var ballRelativeX = 0.0;
var ballRelativeY = 0.0;
var ballRelativeZ = 0.0;

var ballLocationIndex = 0;

// var useTexture;
// var bmiTexture;

var planeGridX = 34;
var planeGridZ = 30;
var planeLengthX = 2.25;
var planeLengthZ = 1.0;
var halfPlaneLenX = planeLengthX / 2.0;
var halfPlaneLenZ = planeLengthZ / 2.0;

var latitudeBands = 50;
var longitudeBands = 50;
var radius = 0.05; 

var scaleBarWidth = 4.15;
var scaleBarHeight = 0.1;
var scaleBarZ = -0.5;

var trenchWidth = 2; // in terms of number of planeGridX
var trenchGrid = trenchWidth * 10;
var trenchDepthScale = 0.02;
var trenchLocations = [];

// var bmiLabelWidth = 1.0;
// var bmiLabelHeight = 0.25;

// 0 -> 7 for ball and plane in color themes
var planeColorSwitch = 3;
var ballColorSwitch = 0;

var planeVertexPositionBuffer;
//var planeVertexColorBuffer;
var planeVertexNormalBuffer;
var planeIndexBuffer;

var ballVertexPositionBuffer;
// var ballVertexColorBuffer;
var ballVertexNormalBuffer;
var ballIndexBuffer;

var rscaleBarVertexPositionBuffer;
var rscaleBarVertexNormalBuffer;
var rscaleBarIndexBuffer;

var oscaleBarVertexPositionBuffer;
var oscaleBarVertexNormalBuffer;
var oscaleBarIndexBuffer;

var gscaleBarVertexPositionBuffer;
var gscaleBarVertexNormalBuffer;
var gscaleBarIndexBuffer;

var rmarkerVertexPositionBuffer;
var omarkerVertexPositionBuffer;
var gmarkerVertexPositionBuffer;

var dialVertexPositionBuffer;
var dialVertexNormalBuffer;
var dialIndexBuffer;

// var bmiLabelVertexPositionBuffer;
// var bmiLabelVertexTextureCoordBuffer;
// var bmiLabelIndexBuffer;

var dialX = 0;

var bmi;

var lastTime = 0;
var idleTick = 0;

function degToRad(degrees) {
    return degrees * Math.PI / 180;
}

function handleMouseDown(event) {
    mouseDown = true;
    lastMouseX = event.clientX;
    lastMouseY = event.clientY;
}

function handleMouseUp(event) {
    mouseDown = false;
}

function handleMouseMove(event) {
    if (!mouseDown) {
        return;
    }

    var newX = event.clientX;
    var newY = event.clientY;

    var deltaX = newX - lastMouseX;

    var newRotationMatrix = mat4.create();
    mat4.identity(newRotationMatrix);
    //mat4.rotate(newRotationMatrix, degToRad(deltaX / 10), [0, 1, 0]);

    var deltaY = newY - lastMouseY;

    if (rAngle <= 150 && rAngle >= 0) {
        if (rAngle + deltaY > 150) {
            deltaY = 150 - rAngle;
            rAngle = 150;
        }
        else if (rAngle + deltaY < 0) {
            deltaY = 0 - rAngle;
            rAngle = 0;
        }
        else {
            rAngle += deltaY;
        }

        mat4.rotate(newRotationMatrix, degToRad(deltaY / 10), [1, 0, 0]);
        mat4.multiply(newRotationMatrix, mvRotationMatrix, mvRotationMatrix);
    }

    lastMouseX = newX
    lastMouseY = newY;
}

function handleKeyDown(event) {
    //alert(event.keyCode);

    var diffX = planeLengthX / planeGridX;
    var diffZ = planeLengthZ / planeGridZ;

    if (event.keyCode == 82) {
        // mat4.identity(mvRotationMatrix);
        // rAngle = 0;
        //console.log(idleTick);
    }
    else if (event.keyCode == 68) {
        //console.log(Math.floor(ballRelativeX/diffX+0.01));
        // if (ballRelativeX >= diffX) {
        //     var index = Math.floor(ballRelativeX/diffX+0.01);
        //     if (!(index > 0 && trenchLocations[index] == 1 && trenchLocations[index-1] == 1)) {
        //         var offset = trenchDepthScale*Math.cos(Math.PI);
        //         ballRelativeY += offset;
        //     }
        //     for (var i = 0; i < planeGridX; i++) {
        //         trenchLocations[i] = 0;
        //     }
        //     trenchLocations[index-1] = 1;
        //     trenchLocations[index] = 1;
        // }
    }
    else if (event.keyCode == 37) {
        idleTick = 0;
        lastTime = 0;
        if (ballRelativeX > radius+diffX) {
            ballRelativeX -= diffX;
            ballRelativeY = ballRelativeX * ballRelativeX / 7.85;

            ballLocationIndex = Math.floor(ballRelativeX/diffX+0.01);
            if (ballLocationIndex > 0 && trenchLocations[ballLocationIndex] == 1 && trenchLocations[ballLocationIndex-1] == 1) {
                if (ballLocationIndex-1 == 0 || trenchLocations[ballLocationIndex+1] == 0 || trenchLocations[ballLocationIndex-2] == 0) {
                    var offset = trenchDepthScale*Math.cos(Math.PI);
                    ballRelativeY += offset;
                }
            }

            bmi = parseFloat(bmi)+1.0;
            document.getElementById("bmi").setAttribute("value", bmi.toFixed(1));

            dialX--;
            if (dialX < 0) dialX = 0;
        }
    }
    else if (event.keyCode == 39) {
        idleTick = 0;
        lastTime = 0;
        if (ballRelativeX <= planeLengthX-radius-diffX) {
            ballRelativeX += diffX;
            ballRelativeY = ballRelativeX * ballRelativeX / 7.85;

            ballLocationIndex = Math.floor(ballRelativeX/diffX+0.01);
            if (ballLocationIndex > 0 && trenchLocations[ballLocationIndex] == 1 && trenchLocations[ballLocationIndex-1] == 1) {
                if (ballLocationIndex-1 == 0 || trenchLocations[ballLocationIndex+1] == 0 || trenchLocations[ballLocationIndex-2] == 0) {
                    var offset = trenchDepthScale*Math.cos(Math.PI);
                    ballRelativeY += offset;
                }
            }

            bmi = parseFloat(bmi)-1.0;
            document.getElementById("bmi").setAttribute("value", bmi.toFixed(1));

            dialX++;
            if (dialX > planeGridX) dialX = planeGridX;
        }
    }
    else if (event.keyCode == 38) {
        if (ballRelativeZ+planeLengthZ > radius*2)
            ballRelativeZ -= diffZ;
    }
    else if (event.keyCode == 40) {
        if (ballRelativeZ < 0-diffZ)
            ballRelativeZ += diffZ;
    }
    else if (event.keyCode == 66) { // ball color switch
        if (ballColorSwitch == colorThemes.length - 1)
            ballColorSwitch = 0;
        else
            ballColorSwitch++;
    }
    else if (event.keyCode == 71) { // plane color switch
        if (planeColorSwitch == colorThemes.length - 1)
            planeColorSwitch = 0;
        else
            planeColorSwitch++;
    }
}

function initGL(canvas) {
    try {
        gl = canvas.getContext("experimental-webgl");
        gl.viewportWidth = canvas.width;
        gl.viewportHeight = canvas.height;
    } catch (e) {

    }
    if (!gl) {
        alert("Could not initialize WebGL, sorry :-(");
    }
}

function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}

function initShaders() {
    var vertexShader = getShader(gl, "shader-vs");
    var fragmentShader = getShader(gl, "shader-fs");

    shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        alert("Could not initialize shaders");
    }

    gl.useProgram(shaderProgram);

    shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

    // shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aTextureCoord");
    // gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);

    shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
    gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);

    // shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
    // gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);

    shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
    shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
    shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");

    // shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");

    shaderProgram.colorUniform = gl.getUniformLocation(shaderProgram, "uColor");
    shaderProgram.reverseLightDirectionLocation = gl.getUniformLocation(shaderProgram, "uReverseLightDirection");

    shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");

    // shaderProgram.useTextureUniform = gl.getUniformLocation(shaderProgram, "uUseTexture");
}

// function handleLoadedTexture(texture) {
//     gl.bindTexture(gl.TEXTURE_2D, texture);
//     gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
//     gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
//     gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
//     gl.bindTexture(gl.TEXTURE_2D, null);
// }

// function initTexture() {
//     bmiTexture = gl.createTexture();
//     bmiTexture.image = new Image();
//     bmiTexture.image.onload = function () {
//         handleLoadedTexture(bmiTexture)
//     }
//     bmiTexture.image.src = "bmi.png";
// }

function mvPushMatrix() {
    var copy = mat4.create();
    mat4.set(mvMatrix, copy);
    mvMatrixStack.push(copy);
}

function mvPopMatrix() {
    if (mvMatrixStack.length == 0) {
        throw "Invalid PopMatrix!";
    }
    mvMatrix = mvMatrixStack.pop();
}

function setMatrixUniforms() {
    gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);

    var normalMatrix = mat3.create();
    normalMatrix = mat4.toInverseMat3(mvMatrix, normalMatrix);
    normalMatrix = mat3.transpose(normalMatrix);
    gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);

    gl.uniform4fv(shaderProgram.colorUniform, colorThemes[object]);
    vec3.normalize(lightDir);
    gl.uniform3fv(shaderProgram.reverseLightDirectionLocation, lightDir);

    gl.uniform1i(shaderProgram.useLightingUniform, lighting);

    // gl.uniform1i(shaderProgram.useTextureUniform, useTexture);
}

function initPlaneBuffers() {
    planeVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
    var vertices = [];
    var normals = [];
    //var colors = [];
    var indices = [];
    var i = 0;
    var d = 0;
    var skip = false;
    var diffX = planeLengthX / planeGridX;
    var diffZ = planeLengthZ / planeGridZ;
    for (var z = -halfPlaneLenZ; z <= halfPlaneLenZ-diffZ; z += diffZ) {
        d = 0;
        for (var x = -halfPlaneLenX; x <= halfPlaneLenX-diffX; x += diffX) {
            if (trenchLocations[d] == 1) {
                if (skip) {
                    d++;
                    skip = false;
                    continue;
                }
                var diff = trenchWidth * diffX / trenchGrid;
                for (var j = 0; j < trenchGrid; j++) {
                    var cosx1 = trenchDepthScale*Math.cos(Math.PI/2.0+j*Math.PI/trenchGrid);
                    var sx1 = x+j*diff;
                    var sy1 = (sx1+halfPlaneLenX)*(sx1+halfPlaneLenX)/8.0 + cosx1;

                    var cosx2 = trenchDepthScale*Math.cos(Math.PI/2.0+(j+1)*Math.PI/trenchGrid);
                    var sx2 = x+(j+1)*diff;
                    var sy2 = (sx2+halfPlaneLenX)*(sx2+halfPlaneLenX)/8.0 + cosx2;

                    vertices.push(sx1);
                    vertices.push(sy1);
                    vertices.push(z);

                    vertices.push(sx2);
                    vertices.push(sy2);
                    vertices.push(z);

                    vertices.push(sx1);
                    vertices.push(sy1);
                    vertices.push(z+diffZ);

                    vertices.push(sx2);
                    vertices.push(sy2);
                    vertices.push(z+diffZ);

                    var p = [sx1, sy1, z];
                    var p1 = [sx1, sy1, z+diffZ];
                    var p2 = [sx2, sy2, z];

                    var a = vec3.create();
                    a = vec3.subtract(p1, p, a);
                    var b = vec3.create();
                    b = vec3.subtract(p2, p, b);

                    var n = vec3.create();
                    n = vec3.cross(a, b, n);

                    for (var c = 0; c < 4; c++) { 
                        normals.push(n[0]);
                        normals.push(n[1]);
                        normals.push(n[2]);
                    }

                    indices.push(i*4);
                    indices.push(i*4+1);
                    indices.push(i*4+3);

                    indices.push(i*4);
                    indices.push(i*4+2);
                    indices.push(i*4+3);

                    i++;
                }
                d++;
                skip = true;
                continue;
            }

            var tmpx = x + halfPlaneLenX;
            var y = (tmpx * tmpx) / 8.0;

            var ttmpx = tmpx + diffX;
            var ny = (ttmpx * ttmpx) / 8.0;

            vertices.push(x);
            vertices.push(y);
            vertices.push(z);

            vertices.push(x+diffX);
            vertices.push(ny);
            vertices.push(z);

            vertices.push(x);
            vertices.push(y);
            vertices.push(z+diffZ);     

            vertices.push(x+diffX);
            vertices.push(ny);
            vertices.push(z+diffZ);       
            //console.log("%f, %f, %f\n", x+diffX, ny, z+diffZ);

            var p = [x, y, z];
            var p1 = [x, y, z+diffZ];
            var p2 = [x+diffX, ny, z];

            var a = vec3.create();
            a = vec3.subtract(p1, p, a);
            var b = vec3.create();
            b = vec3.subtract(p2, p, b);

            var n = vec3.create();
            n = vec3.cross(a, b, n);

            for (var c = 0; c < 4; c++) { 
                normals.push(n[0]);
                normals.push(n[1]);
                normals.push(n[2]);
                //colors = colors.concat(colorThemes[planeColorSwitch]); 
            }

            indices.push(i*4);
            indices.push(i*4+1);
            indices.push(i*4+3);

            indices.push(i*4);
            indices.push(i*4+2);
            indices.push(i*4+3);

            i++;
            d++;
        }
    }
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    planeVertexPositionBuffer.itemSize = 3;
    planeVertexPositionBuffer.numItems = vertices.length / 3; 

    // planeVertexColorBuffer = gl.createBuffer();
    // gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexColorBuffer);
    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    // planeVertexColorBuffer.itemSize = 4;
    // planeVertexColorBuffer.numItems = planeVertexPositionBuffer.numItems; 

    planeVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    planeVertexNormalBuffer.itemSize = 3;
    planeVertexNormalBuffer.numItems = planeVertexPositionBuffer.numItems;


    planeIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);
    // var indices = [];
    // var numSquares = planeGridX * planeGridZ;
    // for (var i = 0; i < numSquares; i++) {
    //     indices.push(i*4);
    //     indices.push(i*4+1);
    //     indices.push(i*4+3);
    //     //console.log("%d, %d, %d\n", i*4, i*4+1, i*4+3);

    //     indices.push(i*4);
    //     indices.push(i*4+2);
    //     indices.push(i*4+3);
    //     //console.log("%d, %d, %d\n", i*4, i*4+2, i*4+3);
    // }
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    planeIndexBuffer.itemSize = 1;
    planeIndexBuffer.numItems = indices.length; 
}

function initBallBuffers() {
    var vertices = [];
    var normals = [];
    for (var latNum = 0; latNum <= latitudeBands; latNum++) {
        var theta = latNum * Math.PI / latitudeBands;
        var sinTheta = Math.sin(theta);
        var cosTheta = Math.cos(theta);

        for (var longNum = 0; longNum <= longitudeBands; longNum++) {
            var phi = longNum * 2 * Math.PI / longitudeBands;
            var sinPhi = Math.sin(phi);
            var cosPhi = Math.cos(phi);

            var x = cosPhi * sinTheta;
            var y = cosTheta;
            var z = sinPhi * sinTheta;

            normals.push(x);
            normals.push(y);
            normals.push(z);

            vertices.push(radius*x);
            vertices.push(radius*y);
            vertices.push(radius*z);
        }
    }

    var indices = [];
    for (var latNum = 0; latNum < latitudeBands; latNum++) {
        for (var longNum = 0; longNum < longitudeBands; longNum++) {
            var first = (latNum * (longitudeBands + 1)) + longNum;
            var second = first + longitudeBands + 1;

            indices.push(first);
            indices.push(second);
            indices.push(first + 1);
            //console.log("%d, %d, %d\n", first, second, first + 1);

            indices.push(second);
            indices.push(second + 1);
            indices.push(first + 1);
            //console.log("%d, %d, %d\n", second, second + 1, first + 1);
        }
    }

    ballVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    ballVertexPositionBuffer.itemSize = 3;
    ballVertexPositionBuffer.numItems = vertices.length / 3;
    //console.log("%d\n", ballVertexPositionBuffer.numItems);

    // ballVertexColorBuffer = gl.createBuffer();
    // gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexColorBuffer);
    // var colors = [];
    // for (var i = 0; i < ballVertexPositionBuffer.numItems; i++)
    //     colors = colors.concat(colorThemes[ballColorSwitch]);
    // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    // ballVertexColorBuffer.itemSize = 4;
    // ballVertexColorBuffer.numItems = ballVertexPositionBuffer.numItems;

    ballVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    ballVertexNormalBuffer.itemSize = 3;
    ballVertexNormalBuffer.numItems = normals.length / 3;

    ballIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ballIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    ballIndexBuffer.itemSize = 1;
    ballIndexBuffer.numItems = indices.length;
    //console.log("%d\n", indices.length);
}

function initRedScaleBarBuffers() {
    var vertices = [];
    var normals = [];
    var indices = [];
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / planeGridX;
    var index = 0;
    var nGrid = 0;
    for (var x = -halfW+nGrid*diffW; x < halfW; x += diffW) {
        if (nGrid == 11) break;

        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        indices.push(index*4);
        indices.push(index*4+1);
        indices.push(index*4+3);

        indices.push(index*4);
        indices.push(index*4+2);
        indices.push(index*4+3);

        index++;
        nGrid++;

        for (var i = 0; i < 4; i++) 
            normals = normals.concat([0.0, 0.0, 1.0]);
    }

    rscaleBarVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, rscaleBarVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    rscaleBarVertexPositionBuffer.itemSize = 3;
    rscaleBarVertexPositionBuffer.numItems = vertices.length / 3;

    rscaleBarVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, rscaleBarVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    rscaleBarVertexNormalBuffer.itemSize = 3;
    rscaleBarVertexNormalBuffer.numItems = normals.length / 3;

    rscaleBarIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rscaleBarIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    rscaleBarIndexBuffer.itemSize = 1;
    rscaleBarIndexBuffer.numItems = indices.length;
}
function initOrangeScaleBarBuffers() {
    var vertices = [];
    var normals = [];
    var indices = [];
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / planeGridX;
    var index = 0;
    var nGrid = 11;
    for (var x = -halfW+nGrid*diffW; x < halfW; x += diffW) {
        if (nGrid == 26) break;

        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        indices.push(index*4);
        indices.push(index*4+1);
        indices.push(index*4+3);

        indices.push(index*4);
        indices.push(index*4+2);
        indices.push(index*4+3);

        index++;
        nGrid++;

        for (var i = 0; i < 4; i++) 
            normals = normals.concat([0.0, 0.0, 1.0]);
    }

    oscaleBarVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, oscaleBarVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    oscaleBarVertexPositionBuffer.itemSize = 3;
    oscaleBarVertexPositionBuffer.numItems = vertices.length / 3;

    oscaleBarVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, oscaleBarVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    oscaleBarVertexNormalBuffer.itemSize = 3;
    oscaleBarVertexNormalBuffer.numItems = normals.length / 3;

    oscaleBarIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, oscaleBarIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    oscaleBarIndexBuffer.itemSize = 1;
    oscaleBarIndexBuffer.numItems = indices.length;
}
function initGreenScaleBarBuffers() {
    var vertices = [];
    var normals = [];
    var indices = [];
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / planeGridX;
    var index = 0;
    var nGrid = 26;
    for (var x = -halfW+nGrid*diffW; x < halfW; x += diffW) {
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x+diffW);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);

        indices.push(index*4);
        indices.push(index*4+1);
        indices.push(index*4+3);

        indices.push(index*4);
        indices.push(index*4+2);
        indices.push(index*4+3);

        index++;
        nGrid++;

        for (var i = 0; i < 4; i++) 
            normals = normals.concat([0.0, 0.0, 1.0]);
    }

    gscaleBarVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gscaleBarVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gscaleBarVertexPositionBuffer.itemSize = 3;
    gscaleBarVertexPositionBuffer.numItems = vertices.length / 3;

    gscaleBarVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gscaleBarVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    gscaleBarVertexNormalBuffer.itemSize = 3;
    gscaleBarVertexNormalBuffer.numItems = normals.length / 3;

    gscaleBarIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gscaleBarIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    gscaleBarIndexBuffer.itemSize = 1;
    gscaleBarIndexBuffer.numItems = indices.length;
}

function initRedMarkerBuffers() {
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / planeGridX;

    var vertices = [];
    var nGrid = 0;
    for (var x = -halfW+nGrid*diffW; x <= halfW; x += diffW) {
        if (nGrid == 12) break;
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);
        nGrid++;
    }

    rmarkerVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, rmarkerVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    rmarkerVertexPositionBuffer.itemSize = 3;
    rmarkerVertexPositionBuffer.numItems = vertices.length / 3;
}
function initOrangeMarkerBuffers() {
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / planeGridX;

    var vertices = [];
    var nGrid = 12;
    for (var x = -halfW+nGrid*diffW; x <= halfW; x += diffW) {
        if (nGrid == 25) break;
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);
        nGrid++;
    }

    omarkerVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, omarkerVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    omarkerVertexPositionBuffer.itemSize = 3;
    omarkerVertexPositionBuffer.numItems = vertices.length / 3;
}
function initGreenMarkerBuffers() {
    var halfW = scaleBarWidth / 2;
    var halfH = scaleBarHeight / 2;
    var diffW = scaleBarWidth / planeGridX;

    var vertices = [];
    var nGrid = 25;
    for (var x = -halfW+nGrid*diffW; x <= halfW; x += diffW) {
        vertices.push(x);
        vertices.push(halfH);
        vertices.push(scaleBarZ);

        vertices.push(x);
        vertices.push(-halfH);
        vertices.push(scaleBarZ);
        nGrid++;
    }

    gmarkerVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, gmarkerVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    gmarkerVertexPositionBuffer.itemSize = 3;
    gmarkerVertexPositionBuffer.numItems = vertices.length / 3;
}

function initDialBuffers() {
    var diffW = scaleBarWidth / planeGridX;
    var halfW = diffW / 3;
    var halfH = scaleBarHeight / 3;

    var vertices = [];
    vertices.push(-halfW);
    vertices.push(halfH);
    vertices.push(scaleBarZ);

    vertices.push(0.0);
    vertices.push(-halfH);
    vertices.push(scaleBarZ);

    vertices.push(halfW);
    vertices.push(halfH);
    vertices.push(scaleBarZ);

    var normals = [];
    for (var i = 0; i < 3; i++) 
        normals = normals.concat([0.0, 0.0, 1.0]);

    var indices = [ 0, 1, 2 ];

    dialVertexPositionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, dialVertexPositionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    dialVertexPositionBuffer.itemSize = 3;
    dialVertexPositionBuffer.numItems = vertices.length / 3;

    dialVertexNormalBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, dialVertexNormalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
    dialVertexNormalBuffer.itemSize = 3;
    dialVertexNormalBuffer.numItems = normals.length / 3;

    dialIndexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dialIndexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
    dialIndexBuffer.itemSize = 1;
    dialIndexBuffer.numItems = indices.length;
}

// function initBMILabelBuffers() {
//     bmiLabelVertexPositionBuffer = gl.createBuffer();
//     gl.bindBuffer(gl.ARRAY_BUFFER, bmiLabelVertexPositionBuffer);
//     var vertices = [];
//     vertices.push(-bmiLabelWidth/2);
//     vertices.push(-bmiLabelHeight/2);
//     vertices.push(0.0);

//     vertices.push(-bmiLabelWidth/2);
//     vertices.push(bmiLabelHeight/2);
//     vertices.push(0.0);

//     vertices.push(bmiLabelWidth/2);
//     vertices.push(bmiLabelHeight/2);
//     vertices.push(0.0);

//     vertices.push(bmiLabelWidth/2);
//     vertices.push(-bmiLabelHeight/2);
//     vertices.push(0.0);
//     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
//     bmiLabelVertexPositionBuffer.itemSize = 3;
//     bmiLabelVertexPositionBuffer.numItems = vertices.length / 3;

//     bmiLabelVertexTextureCoordBuffer = gl.createBuffer();
//     gl.bindBuffer(gl.ARRAY_BUFFER, bmiLabelVertexTextureCoordBuffer);
//     var textureCoords = [
//         1.0, 0.0,
//         0.0, 0.0,
//         0.0, 1.0,
//         1.0, 1.0
//     ];
//     gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
//     bmiLabelVertexTextureCoordBuffer.itemSize = 2;
//     bmiLabelVertexTextureCoordBuffer.numItems = textureCoords.length / 2;

//     bmiLabelIndexBuffer = gl.createBuffer();
//     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bmiLabelIndexBuffer);
//     var indices = [0,1,2, 0,2,3];
//     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
//     bmiLabelIndexBuffer.itemSize = 1;
//     bmiLabelIndexBuffer.numItems = indices.length;
// }

function initBuffers() {
    initPlaneBuffers();

    initBallBuffers();

    initRedScaleBarBuffers();
    initOrangeScaleBarBuffers();
    initGreenScaleBarBuffers();

    initRedMarkerBuffers();
    initOrangeMarkerBuffers();
    initGreenMarkerBuffers();

    initDialBuffers();

    //initBMILabelBuffers();
}

function drawPlane() {
    initPlaneBuffers();

    mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, -0.3, -2.5]);
    mat4.multiply(mvMatrix, mvRotationMatrix);

    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, planeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, planeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    // gl.bindBuffer(gl.ARRAY_BUFFER, planeVertexColorBuffer);
    // gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, planeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, planeIndexBuffer);

    object = planeColorSwitch;
    setMatrixUniforms();
    
    gl.drawElements(gl.TRIANGLES, planeIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    // mvPopMatrix();
}

function drawBall() {
    //initBallBuffers();

    //mvPushMatrix();

    mat4.translate(mvMatrix, [-halfPlaneLenX, radius, halfPlaneLenZ-radius]);

    mat4.translate(mvMatrix, [ballRelativeX, ballRelativeY, ballRelativeZ]);

    gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, ballVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, ballVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    // gl.bindBuffer(gl.ARRAY_BUFFER, ballVertexColorBuffer);
    // gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, ballVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ballIndexBuffer);

    object = ballColorSwitch;
    setMatrixUniforms();
    
    gl.drawElements(gl.TRIANGLES, ballIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    mvPopMatrix();
}

function drawRedScaleBar() {
    mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, -1.1, -3.2]);

    gl.bindBuffer(gl.ARRAY_BUFFER, rscaleBarVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, rscaleBarVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, rscaleBarVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, rscaleBarVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, rscaleBarIndexBuffer);

    object = 8;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, rscaleBarIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //mvPopMatrix();
}
function drawOrangeScaleBar() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.002, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, oscaleBarVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, oscaleBarVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, oscaleBarVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, oscaleBarVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, oscaleBarIndexBuffer);

    object = 9;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, oscaleBarIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //mvPopMatrix();
}
function drawGreenScaleBar() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.002, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, gscaleBarVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, gscaleBarVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, gscaleBarVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, gscaleBarVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gscaleBarIndexBuffer);

    object = 10;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, gscaleBarIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    //mvPopMatrix();
}

function drawRedMarker() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, -0.004, 0.001]);

    gl.bindBuffer(gl.ARRAY_BUFFER, rmarkerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, rmarkerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms();

    gl.drawArrays(gl.LINES, 0, rmarkerVertexPositionBuffer.numItems);

    //mvPopMatrix();
}
function drawOrangeMarker() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, omarkerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, omarkerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms();

    gl.drawArrays(gl.LINES, 0, omarkerVertexPositionBuffer.numItems);

    //mvPopMatrix();
}
function drawGreenMarker() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);

    gl.bindBuffer(gl.ARRAY_BUFFER, gmarkerVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, gmarkerVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    setMatrixUniforms();

    gl.drawArrays(gl.LINES, 0, gmarkerVertexPositionBuffer.numItems);

    //mvPopMatrix();
}

function drawDial() {
    //mvPushMatrix();

    mat4.translate(mvMatrix, [dialX*scaleBarWidth/planeGridX-scaleBarWidth/2, scaleBarHeight-0.017, 0.001]);

    gl.bindBuffer(gl.ARRAY_BUFFER, dialVertexPositionBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, dialVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ARRAY_BUFFER, dialVertexNormalBuffer);
    gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, dialVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, dialIndexBuffer);

    object = 1;
    setMatrixUniforms();

    gl.drawElements(gl.TRIANGLES, dialIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

    mvPopMatrix();
}

// function drawBMILabel() {
//     mvPushMatrix();

//     mat4.translate(mvMatrix, [0.0, 0.0, 0.0]);

//     gl.bindBuffer(gl.ARRAY_BUFFER, bmiLabelVertexPositionBuffer);
//     gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, bmiLabelVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

//     gl.bindBuffer(gl.ARRAY_BUFFER, bmiLabelVertexTextureCoordBuffer);
//     gl.vertexAttribPointer(shaderProgram.textureCoordAttribute, bmiLabelVertexTextureCoordBuffer.itemSize, gl.FLOAT, false, 0, 0);

//     gl.activeTexture(gl.TEXTURE0);
//     gl.bindTexture(gl.TEXTURE_2D, bmiTexture);
//     gl.uniform1i(shaderProgram.samplerUniform, 0);

//     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bmiLabelIndexBuffer);

//     setMatrixUniforms();

//     gl.drawElements(gl.TRIANGLES, bmiLabelIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

//     mvPopMatrix();
// }

function drawScene() {
    gl.clearColor(0.0, 0.0, 0.0, 1.0);
    gl.enable(gl.DEPTH_TEST);

    gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 1000.0, pMatrix);

    mat4.identity(mvMatrix);

    lighting = true;
    // useTexture = false;
    //gl.disableVertexAttribArray(shaderProgram.textureCoordAttribute);
    drawPlane();

    drawBall();

    drawRedScaleBar();
    drawOrangeScaleBar();
    drawGreenScaleBar();

    lighting = false;
    drawRedMarker();
    drawOrangeMarker();
    drawGreenMarker();
    lighting = true;

    drawDial();

    //lighting = false;
    //useTexture = true;
    //gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
    //drawBMILabel();
}

function animate() {
    var timeNow = new Date().getTime();
    if (lastTime != 0) {
        var elapsed = timeNow - lastTime;

        idleTick += elapsed / 1000;

        if (idleTick > 5) {
            if (ballLocationIndex > 0) {
                if (trenchLocations[ballLocationIndex] == 0 || trenchLocations[ballLocationIndex-1] == 0) {
                    var offset = trenchDepthScale*Math.cos(Math.PI);
                    ballRelativeY += offset;
                }
                else if (trenchLocations[ballLocationIndex] == 1 && trenchLocations[ballLocationIndex-1] == 1 && trenchLocations[ballLocationIndex+1] == 1 && trenchLocations[ballLocationIndex-2] == 1) {
                    var offset = trenchDepthScale*Math.cos(Math.PI);
                    ballRelativeY += offset;
                }

                if (trenchLocations[ballLocationIndex] == 1 && trenchLocations[ballLocationIndex-1] == 1) {
                    if (trenchLocations[ballLocationIndex+1] == 1 && trenchLocations[ballLocationIndex-2] == 1) {
                        trenchLocations[ballLocationIndex+1] = 0;
                        trenchLocations[ballLocationIndex-2] = 0;
                    }
                }
                else if (trenchLocations[ballLocationIndex] == 1) {
                    trenchLocations[ballLocationIndex+1] = 0;
                }
                else if (trenchLocations[ballLocationIndex-1] == 1) {
                    trenchLocations[ballLocationIndex-2] = 0;
                }
                trenchLocations[ballLocationIndex-1] = 1;
                trenchLocations[ballLocationIndex] = 1;
            }
        }
    }
    lastTime = timeNow;
}

function tick() {
    requestAnimFrame(tick);

    drawScene();
    animate();
}

function webGLStart() {
    var canvas = document.getElementById("myCanvas");

    initGL(canvas);
    initShaders();
    initBuffers();
    // initTexture();

    canvas.onmousedown = handleMouseDown;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;

    document.onkeydown = handleKeyDown;

    bmi = document.getElementById("bmi").value;

    for (var i = 0; i < planeGridX; i++) {
        trenchLocations[i] = 0;
    }

    tick();
}

</script>

</head>

<body onload="webGLStart();">
<p style="text-align: center;"><b>mouse hold and drag</b> - rotate the scene<br><b>'g'</b> - change the color of the plane, <b>'b'</b> - change the color of the ball<br><b>left, right, up, down arrows</b> - move the ball on the plane</p>
<canvas id="myCanvas" style="padding: 0; margin: auto; display: block;" width="1200" height="600"></canvas>
<table style="border: 0; padding: 10px; margin: auto;">
<tr><td><b>BMI: </b><input type="text" id="bmi" value="51.0" disabled style="text-align: center;" /></tr>
</table>
</body>

</html>